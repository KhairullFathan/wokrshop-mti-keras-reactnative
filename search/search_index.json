{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":[" "]},"docs":[{"location":"","title":"Selamat Datang di Dokumentasi Workshop","text":"<p>Dokumentasi ini berisi panduan lengkap mengenai proses pengembangan workshop implementasi model <code>.keras</code> ke aplikasi berbasis React Native. Semua langkah disusun agar Anda dapat memahami alur kerja dari persiapan dataset hingga integrasi model pada aplikasi mobile.</p>"},{"location":"#daftar-isi","title":"Daftar Isi","text":"<ul> <li>Persiapan Dataset   Panduan menyiapkan dataset yang digunakan untuk proses pelatihan dan pengujian model.</li> <li>Training &amp; Testing Model   Langkah-langkah melatih model <code>.keras</code>, melakukan pengujian, serta menganalisis hasilnya.</li> <li>Backend   Penjelasan arsitektur backend, API, dan integrasi dengan model untuk mendukung aplikasi mobile.</li> <li>Frontend   Desain antarmuka dan implementasi fitur pada aplikasi React Native.</li> </ul>"},{"location":"#tujuan-dokumentasi","title":"Tujuan Dokumentasi","text":"<ol> <li>Memberikan panduan yang jelas untuk memahami alur pengembangan workshop.</li> <li>Memudahkan peserta dalam mengikuti langkah-langkah integrasi model <code>.keras</code> ke aplikasi React Native.</li> <li>Menjadi referensi saat melakukan pemeliharaan atau pengembangan lebih lanjut.</li> </ol>"},{"location":"#teknologi-yang-digunakan","title":"Teknologi yang Digunakan","text":"<ul> <li>Python untuk machine learning &amp; backend</li> <li>TensorFlow / Keras untuk pelatihan model</li> <li>React Native untuk aplikasi mobile</li> </ul>"},{"location":"#tools-requirement","title":"Tools Requirement","text":"<ul> <li>Node.js versi terbaru Download Node.js</li> <li>Python 3.12.0 Download Python</li> <li>Visual Studio Code sebagai code editor utama Download VS Code</li> </ul>"},{"location":"001-dataset/","title":"1. Penyiapan dataset","text":""},{"location":"001-dataset/#11-sumber-dataset","title":"1.1. Sumber Dataset","text":"<p>Dataset yang digunakan berasal dari platform Kaggle: \ud83d\udd17 Handwritten Digits 0-9 Dataset</p>"},{"location":"001-dataset/#12-deskripsi-dataset","title":"1.2 Deskripsi Dataset","text":"<p>Dataset ini berisi gambar angka tulisan tangan dari 0 hingga 9 dengan karakteristik khusus:</p> <ul> <li>Jumlah Data: Sekitar 21.600 gambar angka</li> <li>Format: Gambar berwarna (full color) dalam format .jpg</li> <li>Dimensi: 90x140 piksel</li> <li>Asal Notasi: Menggunakan notasi angka Eropa (Swiss)</li> </ul>"},{"location":"001-dataset/#13-keunikan-dataset","title":"1.3 Keunikan Dataset","text":"<p>Dataset ini memiliki beberapa ciri khas yang membedakannya dari MNIST:</p> <p>Notasi Eropa:</p> <ul> <li>Khususnya angka 1 dan 7 memiliki gaya penulisan yang berbeda dengan notasi Amerika</li> <li>Beberapa angka mungkin memiliki border hitam kecil di sekelilingnya</li> </ul> <p>Format Gambar:</p> <ul> <li>Berwarna (RGB) dibanding MNIST yang grayscale</li> <li>Resolusi lebih besar (90x140px) dibanding MNIST (28x28px)</li> </ul>"},{"location":"002-TraningTesting/","title":"2. Proses Training dan Testing Dataset di Google Colab","text":""},{"location":"002-TraningTesting/#21-persiapan-data","title":"2.1. Persiapan Data","text":""},{"location":"002-TraningTesting/#211-load-dan-ekstrak-dataset-dari-google-drive","title":"2.1.1. Load dan Ekstrak Dataset dari Google Drive","text":"<p>Dataset dalam format <code>.zip</code> diakses langsung dari Google Drive.</p> <pre><code>from google.colab import drive\nimport zipfile\n\n# Mount Google Drive\ndrive.mount('/content/drive')\n\n# Path dataset di Google Drive\npath = \"digit-handwritten\"\ndataPath = f\"/content/drive/MyDrive/workshop/{path}.zip\"\n\n# Ekstrak dataset\nzip_ref = zipfile.ZipFile(dataPath, 'r')\nzip_ref.extractall(path)  # Ekstrak ke direktori root Colab\nzip_ref.close()\n\nprint(f\"Dataset berhasil diekstrak ke folder: {path}\")\n</code></pre>"},{"location":"002-TraningTesting/#catatan","title":"Catatan:","text":"<ul> <li>Pastikan file zip sudah ada di Google Drive sebelum menjalankan kode.</li> <li>Jika file zip berada dalam folder tertentu di Drive, pastikan <code>dataPath</code> sesuai, misalnya jika berada dalam folder <code>workshop</code>:   <pre><code>dataPath = f\"/content/drive/MyDrive/workshop/{path}.zip\"\n</code></pre></li> <li>Jika ingin menyimpan hasil ekstraksi di folder tertentu di Drive, gunakan:   <pre><code>zip_ref.extractall(f\"/content/drive/MyDrive/target_folder/{path}\")\n</code></pre></li> </ul>"},{"location":"002-TraningTesting/#212-split-data-train-validation-test","title":"2.1.2. Split Data (Train, Validation, Test)","text":"<p>Menggunakan <code>split_folders</code> untuk membagi dataset menjadi train (70%), validation (20%), dan test (10%).</p> <pre><code>!pip install split-folders\nimport splitfolders\n\n# Split dataset\nsplitfolders.ratio(\n  path,                      # Folder dataset asli di yang berada di root google colab\n  output=\"split_dataset\",    # Folder output hasil split\n  seed=42,                   # Random seed untuk reproducibility\n  ratio=(0.7, 0.2, 0.1),     # Rasio train, val, test\n  group_prefix=None          # Tidak mengelompokkan berdasarkan prefix\n)\n</code></pre>"},{"location":"002-TraningTesting/#22-persiapan-data-dengan-imagedatagenerator","title":"2.2. Persiapan Data dengan <code>ImageDataGenerator</code>","text":"<p>Menggunakan <code>ImageDataGenerator</code> untuk augmentasi data dan normalisasi.</p> <pre><code>from tensorflow.keras.preprocessing.image import ImageDataGenerator\n\n# Konfigurasi ukuran gambar\nimg_height, img_width = 140, 90  # Sesuaikan dengan dimensi dataset atau input layer pada CNN\nBATCH_SIZE = 32\n\ndef create_data(directory):\n  # Augmentasi untuk data training\n  train_datagen = ImageDataGenerator(\n    rescale=1.0 / 255,           # Normalisasi pixel [0, 1]\n    rotation_range=40,           # Rotasi gambar \u00b140 derajat\n    width_shift_range=0.2,       # Geser horizontal 20%\n    height_shift_range=0.2,      # Geser vertikal 20%\n    shear_range=0.2,             # Shear transformasi\n    zoom_range=0.2,              # Zoom in/out 20%\n    horizontal_flip=True,        # Flip horizontal\n    fill_mode='nearest'          # Isi pixel kosong dengan nearest\n  )\n\n  # Hanya normalisasi untuk validation &amp; test (tanpa augmentasi)\n  val_test_datagen = ImageDataGenerator(rescale=1.0 / 255)\n\n  # Generator untuk data training\n  train_ds = train_datagen.flow_from_directory(\n    f\"./{directory}/train\",\n    target_size=(img_height, img_width),\n    class_mode='categorical',\n    batch_size=BATCH_SIZE,\n    shuffle=True\n  )\n\n  # Generator untuk data validation\n  val_ds = val_test_datagen.flow_from_directory(\n    f\"./{directory}/val\",\n    target_size=(img_height, img_width),\n    class_mode='categorical',\n    batch_size=BATCH_SIZE,\n    shuffle=True\n  )\n\n  # Generator untuk data testing\n  test_ds = val_test_datagen.flow_from_directory(\n    f\"./{directory}/test\",\n    target_size=(img_height, img_width),\n    class_mode='categorical',\n    batch_size=BATCH_SIZE,\n    shuffle=False  # Tidak di-shuffle untuk evaluasi\n  )\n\n  return train_ds, val_ds, test_ds\n\n# Panggil fungsi untuk membuat dataset\ntrain_ds, val_ds, test_ds = create_data(\"split_dataset\")\n</code></pre>"},{"location":"002-TraningTesting/#23-membangun-model-sederhana-untuk-training","title":"2.3. Membangun Model Sederhana untuk Training","text":"<p>Menggunakan CNN (Convolutional Neural Network) dengan arsitektur dasar.</p> <pre><code>import tensorflow as tf\nfrom tensorflow.keras import layers, models\n\n# Membangun model CNN\nmodel = models.Sequential([\n  # Blok Convolutional 1\n  layers.Conv2D(32, (3, 3), activation='relu', input_shape=(img_height, img_width, 3)),\n  layers.MaxPooling2D((2, 2)),\n\n  # Blok Convolutional 2\n  layers.Conv2D(64, (3, 3), activation='relu'),\n  layers.MaxPooling2D((2, 2)),\n\n  # Blok Convolutional 3\n  layers.Conv2D(128, (3, 3), activation='relu'),\n  layers.MaxPooling2D((2, 2)),\n\n  # Flatten untuk Fully Connected Layer\n  layers.Flatten(),\n\n  # Dense Layers\n  layers.Dense(256, activation='relu'),\n  layers.Dropout(0.5),  # Dropout untuk mengurangi overfitting\n  layers.Dense(10, activation='softmax')  # Output layer (10 kelas angka 0-9)\n])\n\n# Kompilasi model\nmodel.compile(\n  optimizer='adam',\n  loss='categorical_crossentropy',\n  metrics=['accuracy']\n)\n\n# Ringkasan model\nmodel.summary()\n</code></pre>"},{"location":"002-TraningTesting/#24-training-model","title":"2.4. Training Model","text":"<p>Melatih model menggunakan <code>model.fit()</code>.</p> <pre><code># Training model\nhistory = model.fit(\n  train_ds,\n  validation_data=val_ds,\n  epochs=5,  # Jumlah epoch maksimum\n)\n</code></pre>"},{"location":"002-TraningTesting/#plot-hasil-training","title":"Plot Hasil Training","text":"<pre><code>import matplotlib.pyplot as plt\n\nacc = history.history['accuracy']\nloss = history.history['loss']\nvalAcc = history.history['val_accuracy']\nvalLoss = history.history['val_loss']\n\nepochs = range(len(acc))\n# show image\nfig, axs = plt.subplots(1, 2, figsize=(14, 6))\n\n# Accuracy\naxs[0].plot(epochs, acc, label='Training Accuracy')\naxs[0].plot(epochs, valAcc, label='Validation Accuracy')\naxs[0].set_xlabel(\"Epochs\")\naxs[0].set_ylabel('Model Accuracy')\naxs[0].legend()\n\n# Loss\naxs[1].plot(epochs, loss, label='Training Loss')\naxs[1].plot(epochs, valLoss, label='Validation Loss')\naxs[1].set_xlabel(\"Epochs\")\naxs[1].set_ylabel('Model Loss')\naxs[1].legend()\nplt.show()\n</code></pre>"},{"location":"002-TraningTesting/#25-evaluasi-model","title":"2.5. Evaluasi Model","text":"<p>Menguji model dengan data testing.</p> <pre><code># Evaluasi model\ntest_loss, test_acc = model.evaluate(test_ds)\nprint(f\"Test Accuracy: {test_acc * 100:.2f}%\")\n</code></pre>"},{"location":"002-TraningTesting/#26-simpan-model-dalam-format-keras","title":"2.6. Simpan Model dalam format <code>.keras</code>","text":"<p>Model yang sudah dilatih disimpan dalam format <code>nama-model.keras</code> sehingga dapat diimplementasikan pada aplikasi mobile android.</p> <pre><code>from google.colab import files\n# Save model\nmodel.save(\"handwritten_digits_model.keras\")\n# Download model\nfiles.download(\"handwritten_digits_model.keras\")\n</code></pre> <p>\ud83c\udf89 Model siap digunakan untuk prediksi angka tulisan tangan! \ud83d\ude80</p>"},{"location":"003-backend/","title":"3. Pengembangan Backend dengan Python","text":""},{"location":"003-backend/#31-persiapan-lingkungan-pengembangan","title":"3.1. Persiapan Lingkungan Pengembangan","text":""},{"location":"003-backend/#311-verifikasi-instalasi-python","title":"3.1.1. Verifikasi Instalasi Python","text":"<p>Pastikan Python sudah terinstall di sistem Anda:</p> <pre><code>python --version\n# atau\npython3 --version\n</code></pre> <p>Jika belum terinstall, download dari python.org</p>"},{"location":"003-backend/#312-inisialisasi-project","title":"3.1.2. Inisialisasi Project","text":"<p>Buat folder project dan virtual environment:</p> <pre><code># Membuat folder project\nD:                                                # masuk ke partisi D\nmkdir digit-recognition &amp;&amp; cd digit-recognition   # membuat directory digit-recognition dan masuk ke directory\nmkdir backend &amp;&amp; cd backend                       # membuat directory backend dan masuk ke directory\n\n\npython -m venv venv                               # membuat virtual environment\n\n# Aktifkan virtual environment\n.\\venv\\Scripts\\activate                           # untuk Windows:\n\nsource venv/bin/activate                          # untuk Linux/Mac:\n</code></pre>"},{"location":"003-backend/#313-install-dependencies","title":"3.1.3. Install Dependencies","text":"<p>Install package yang diperlukan:</p> <pre><code>pip install tensorflow==2.19.0 Flask==3.1.1 Pillow==11.3.0 flask_cors\n</code></pre> <p>Buat file <code>requirements.txt</code> untuk menyimpan daftar dependencies:</p> <pre><code>pip freeze &gt; requirements.txt\n</code></pre>"},{"location":"003-backend/#32-struktur-project","title":"3.2. Struktur Project","text":"<pre><code>digit-recognition/\n\u251c\u2500\u2500 backend/                  # Backend service\n\u2502   \u251c\u2500\u2500 venv/                 # Python virtual environment\n\u2502   \u251c\u2500\u2500 static/               # Direktori flask untuk menyimpan file statis\n\u2502   \u2502   \u2514\u2500\u2500 uploads/          # Direktori upload dari sisi client\n\u2502   \u251c\u2500\u2500 app.py                # Flask application\n\u2502   \u2514\u2500\u2500 model.keras           # Trained model\n\u2514\u2500\u2500 frontend/                 # Frontend application\n</code></pre>"},{"location":"003-backend/#33-implementasi-flask-backend","title":"3.3. Implementasi Flask Backend","text":""},{"location":"003-backend/#331-import-library","title":"3.3.1. Import Library","text":"<p>Sebelum memulai pengembangan backend, kita perlu mengimpor berbagai library yang akan digunakan.</p> <pre><code>import os                                                # library untuk interaksi dengan filesystem\nimport io                                                # library untuk penanganan stream I/O\nimport time                                              # library untuk penanganan waktu\n\nimport tensorflow as tf                                  # library machine learning\nimport numpy as np                                       # library komputasi numerik\n\nfrom flask import Flask, request, json, jsonify, url_for # framework flask untuk webservice\nfrom flask_cors import CORS                              # library flask tambahan untuk handle Cross-Origin\n\nfrom PIL import Image                                    # library untuk proses gambar\n</code></pre>"},{"location":"003-backend/#332-public-variabel","title":"3.3.2. Public Variabel","text":"<p>Pada tahap ini, kita akan mendefinisikan beberapa variabel publik yang digunakan sebagai konfigurasi awal program. Variabel ini mencakup daftar kelas yang akan dikenali oleh model, jumlah total kelas, pemanggilan model yang telah dilatih sebelumnya, serta penentuan ekstensi file gambar yang diizinkan untuk diproses.</p> <pre><code>CLASS = ['0','1','2','3','4','5','6','7','8','9']   # daftar kelas yang dikenali model\nCLASS_LEN = len(CLASS)                              # jumlah total kelas\nMODEL = tf.keras.models.load_model('model.keras')   # load model yang telah dilatih sebelumnya\nALLOWED_EXT = set(['jpg', 'png', 'jpeg'])           # daftar extension file yang diizinkan\n</code></pre>"},{"location":"003-backend/#333-inisialisasi-flask-app-endpoint","title":"3.3.3. Inisialisasi Flask APP &amp; Endpoint <code>/</code>","text":"<p>Pada bagian ini dilakukan inisialisasi Flask App yang akan berfungsi sebagai server utama untuk menangani permintaan (request) dari pengguna. Selain itu, diaktifkan juga fitur CORS (Cross-Origin Resource Sharing) agar API dapat diakses dari berbagai domain. Selanjutnya, dibuat endpoint root (/) yang akan menampilkan pesan sederhana sebagai indikasi bahwa Digit Recognition API telah berjalan.</p> <pre><code>app = Flask(__name__)                                         # membuat objek `app` yang merupakan instance dari Flask\nCORS(app)                                                     # mengaktifkan fitur CORS\n\n@app.route('/')                                               # mendefinisikan route `/` (root) secara default methods = ['GET']\ndef home():                                                   # inisialisasi fungsi `home()`, yang dijalankan ketika mengakses endpoint `/`\n  return jsonify({'message':'Digit Recognition API'}), 200    # mengembalikan respon dalam bentuk json dengan http status code 200\n\nif __name__ == '__main__':\n  port = 5000                                                 # inisialisasi port\n  print(f\"Server sedang berjalan di http://0.0.0.0:${port}\")  # cetak console\n  app.run(debug=True, host='0.0.0.0', port=port)              # running flask app\n</code></pre>"},{"location":"003-backend/#334-menjalankan-aplikasi-flask-testing-request","title":"3.3.4. Menjalankan Aplikasi Flask &amp; Testing request <code>/</code>","text":"<p>Setelah proses inisialisasi dan pembuatan endpoint selesai, langkah selanjutnya adalah menjalankan aplikasi Flask. Aplikasi dapat dijalankan dengan dua cara, yaitu menggunakan perintah flask run atau langsung mengeksekusi file Python yang berisi kode program.</p> <pre><code>flask run\n# atau\npython app.py\n</code></pre> <p>Setelah aplikasi berjalan, langkah selanjutnya mencoba untuk testing endpoint <code>/</code>, untuk mengetahui aplikasi telah berjalan dengan baik.</p> <pre><code>curl -X GET  http://localhost:5000/predict\n</code></pre>"},{"location":"003-backend/#335-endpoint-predict","title":"3.3.5. Endpoint <code>predict/</code>","text":"<p>Pada bagian ini dibuat endpoint /predict yang berfungsi untuk menerima file gambar dari pengguna melalui metode POST, kemudian memprosesnya menggunakan model yang telah dilatih untuk menghasilkan prediksi digit. Endpoint ini juga mengembalikan hasil klasifikasi beserta persentase probabilitasnya dalam format JSON.</p> <pre><code>@app.route('/predict', methods=['POST'])                  # mendefinisikan route `/predict` dengan methods ['POST']\ndef predict():                                            # inisialisasi fungsi `predict()`, yang dijalankan ketika mengakses endpoint `/predict`\n  if 'file' not in request.files:                         # mengecek pakah request dari client mengirimkan file dengan nama 'file'\n    return jsonify({'error': 'No file uploaded'}), 400    # mengembalikan respon json\n\n  file = request.files['file']                            # file yang dikirimkan dari client disimpan pada variabel 'file'\n  fileExtension = file.filename.split('.')[-1].lower()    # mengambil extension file\n\n  if not (fileExtension in ALLOWED_EXT):                  # mengecek apakah extension file diizinkan\n    return jsonify({\"error\":\"Not allowed file extension.\"}), 400 # mengembalikan respon json\n\n  newName = f\"{time.time_ns()}.{fileExtension}\"           # membuat nama unik dari timestamp\n  imagePath = f\"./static/uploads/{newName}\"               # inisialisasi path penyimpanan\n  file.save(imagePath)                                    # save file upload ke dalam path dan nama baru\n\n  if not (os.path.exists(imagePath)):                     # memeriksa file yang di upload benar-benar berhasil tersimpan\n    return jsonify({\"error\":\"File not uploaded\"}),404     # mengembalikan respon json jika file tidak ada\n\n  try:\n    image = Image.open(imagePath).convert('RGB')          # membuka file sesuai dengan path dan convert ke mode RGB\n    image = image.resize((90, 140))                       # resize ukuran agar sesuai dengan model cnn\n    imgArray = np.array(image) / 255.0                    # normalisasi\n    imgArray = np.expand_dims(imgArray, axis=0)           # menambahkan dimensi agar sesuai dengan input model\n\n    predictions = model.predict(imgArray)                 # fungsi prediksi dengan model .keras\n    dictResult = {i: classes[i] for i in range(classLen)} # inisialisasi dictionary untuk mapping label kelas\n\n    res = predictions[0]                                  # mengambil hasil prediksi indeks [0]\n\n    sortedIndex = res.argsort()[::-1]                     # melakukan sort indeks kelas berdasarkan probabilitas tertinggi\n    prob = res[sortedIndex[:classLen]]                    # melakukan probabilitas hasil prediksi sesuai urutan\n\n    classificationResult = []                             # inisialisasi list hasil klasifikasi\n\n    for i in range(classLen):                             # looping sebanyak jumlah kelas\n      # membuat objek sementara untuk menyimpan nama kelas dan probabilitas\n      resultDict = {\n        'class': dictResult[sortedIndex[i]],              # mengambil label kelas\n        'prob': round(float(prob[i] * 100), 2)            # mengambil probabilitas, di konversi ke dalam persen (%) dan dibulatkan hanya mengambil 2 angka desimal\n      }\n      classificationResult.append(resultDict)             # menambahkan objek 'resultDict' ke list hasil klasifikasi\n\n    # mengembalikan respon dalam bentuk json\n    return jsonify({\n      'classification_result': classificationResult,\n    }), 200\n\n  except Exception as e:                                  # mengembalikan error jika terjadi kesalahan pada block try\n    return jsonify({'error': str(e)}), 500                # mengembalikan pesan error dengan kode 500\n</code></pre>"},{"location":"003-backend/#336-testing-request-predict","title":"3.3.6. Testing request <code>predict/</code>","text":"<pre><code>curl -X POST -F \"file=@D:\\0004DEV\\008Experimen\\DigitHadwriting\\dataset\\2\\Two_full (1).jpg\" http://localhost:5000/predict\n</code></pre>"},{"location":"003-backend/#337-kode-lengkap-apppy","title":"3.3.7. Kode Lengkap <code>app.py</code>","text":"<pre><code># import library\nimport os\nimport io\nimport time\nimport tensorflow as tf\nimport numpy as np\nfrom flask import Flask, request, json, jsonify, url_for\nfrom flask_cors import CORS\nfrom PIL import Image\n\n# Public Variabel\nCLASS = ['0','1','2','3','4','5','6','7','8','9']\nCLASS_LEN = len(CLASS)\nMODEL = tf.keras.models.load_model('model.keras')\nALLOWED_EXT = set(['jpg', 'png', 'jpeg'])\n\n# Inisialisasi Flask APP &amp; Endpoint '/'\napp = Flask(__name__)\nCORS(app)\n\n@app.route('/')\ndef home():\n  return jsonify({'message':'Digit Recognition API'}), 200\n\n# Endpoint 'predict/'\n@app.route('/predict', methods=['POST'])\ndef predict():\n  if 'file' not in request.files:\n    return jsonify({'error': 'No file uploaded'}), 400\n\n  file = request.files['file']\n  fileExtension = file.filename.split('.')[-1].lower()\n\n  if not (fileExtension in ALLOWED_EXT):\n    return jsonify({\"error\":\"Not allowed file extension.\"}), 400\n\n  newName = f\"{time.time_ns()}.{fileExtension}\"\n  imagePath = f\"./static/uploads/{newName}\"\n  file.save(imagePath)\n\n  if not (os.path.exists(imagePath)):\n    return jsonify({\"error\":\"File not uploaded\"}),404\n\n  try:\n    image = Image.open(imagePath).convert('RGB')\n    image = image.resize((90, 140))\n    imgArray = np.array(image) / 255.0\n    imgArray = np.expand_dims(imgArray, axis=0)\n\n    predictions = MODEL.predict(imgArray)\n    dictResult = {i: CLASS[i] for i in range(CLASS_LEN)}\n\n    res = predictions[0]\n\n    sortedIndex = res.argsort()[::-1]\n    prob = res[sortedIndex[:CLASS_LEN]]\n\n    classificationResult = []\n\n    for i in range(CLASS_LEN):\n      resultDict = {\n        'class': dictResult[sortedIndex[i]],\n        'prob': round(float(prob[i] * 100), 2)\n      }\n      classificationResult.append(resultDict)\n\n    return jsonify({\n      'classification_result': classificationResult,\n      'image_url': url_for('static', filename=f'uploads/{newName}', _external=True)\n    }), 200\n\n  except Exception as e:\n    return jsonify({'error': str(e)}), 500\n\n\nif __name__ == '__main__':\n  port = 5000\n  print(f\"Server sedang berjalan di http://0.0.0.0:{port}\")\n  app.run(debug=True, host='0.0.0.0', port=port)\n</code></pre>"},{"location":"004-frontend/","title":"4. Pengembangan Frontend dengan React Native","text":""},{"location":"004-frontend/#41-persiapan-lingkungan-pengembangan","title":"4.1. Persiapan Lingkungan Pengembangan","text":""},{"location":"004-frontend/#411-verifikasi-instalasi-nodejs","title":"4.1.1. Verifikasi Instalasi nodejs","text":"<p>Pastikan Python sudah terinstall di sistem Anda:</p> <pre><code>node --version\n# atau\nnode -v\n</code></pre> <p>Jika belum terinstall, download dari nodejs.org</p>"},{"location":"004-frontend/#412-inisialisasi-project","title":"4.1.2. Inisialisasi Project","text":"<p>Langkah pertama dalam membangun aplikasi frontend adalah membuat struktur folder project dan menginisialisasi project Expo. Pada tahap ini, kita akan membuat folder khusus untuk frontend, lalu menjalankan perintah untuk membuat project Expo di dalamnya.</p> <pre><code>D:                                  # masuk ke partisi D\ncd digit-recognition                # masuk ke directory digit-recognition\nmkdir frontend &amp;&amp; cd frontend       # membuat directory frontend dan masuk ke directory frontend\n\nnpx create-expo-app@latest .        # membuat project expo di directory `.` (terkini dalam hal ini frontend)\n</code></pre> <p>Proses <code>npx create-expo-app</code> akan memakan waktu beberapa menit, tergantung pada kecepatan koneksi internet dan spesifikasi perangkat yang digunakan, karena perintah ini akan mengunduh dependensi dan mengonfigurasi struktur dasar aplikasi. Setelah proses selesai, folder project akan berisi file dan direktori bawaan yang siap digunakan untuk pengembangan aplikasi React Native berbasis Expo.</p> <p>Secara default, Expo akan menghasilkan beberapa direktori dan file bawaan sebagai dokumentasi dan contoh penggunaan. Jika ingin memulai dari struktur project yang lebih bersih, Anda dapat menggunakan perintah:</p> <pre><code>npm run reset-project\n</code></pre> <p>Perintah ini akan memindahkan file dan direktori contoh yang tidak diperlukan ke dalam directory <code>app-example</code>, sehingga project menjadi lebih rapi dan siap untuk dikembangkan sesuai kebutuhan aplikasi yang akan dibuat.</p>"},{"location":"004-frontend/#413-install-library-tambahan-yang-diperlukan","title":"4.1.3. Install library tambahan yang diperlukan","text":"<p>Tahap ini bertujuan untuk menginstal library tambahan yang akan digunakan pada aplikasi frontend. Masing-masing library memiliki fungsi tertentu, mulai dari melakukan HTTP request hingga menampilkan grafik. Berikut perintah dan penjelasannya:</p> <pre><code>npm install axios                         # Menginstal Axios, library untuk melakukan HTTP request (GET, POST, dll) ke backend API\nnpm expo-image-picker                     # Menginstal modul Expo untuk memilih gambar dari galeri\nnpx expo install react-native-svg         # Menginstal react-native-svg untuk manipulasi gambar berbasis SVG\nnpx expo install react-native-chart-kit   # Menginstal library untuk membuat grafik/chart pada React Native\nnpx expo install lodash                   # Menginstal Lodash, library utilitas untuk manipulasi data (array, objek, dll)\nnpx expo install @expo/ngrok              # Menginstal @expo/ngrok, library untuk tunnel agar bisa di expose ke jaringan public\n</code></pre>"},{"location":"004-frontend/#414-menjalankan-project-expo","title":"4.1.4. Menjalankan Project Expo","text":"<p>Setelah semua library tambahan berhasil diinstal, langkah berikutnya adalah menjalankan project Expo untuk memastikan bahwa instalasi berhasil dan aplikasi dapat berjalan di perangkat pengembangan. Gunakan perintah berikut:</p> <pre><code>npm start\n# atau\nnpx expo start\n\nnpx start --tunnel\n# atau\nnpx expo start --tunnel\n</code></pre> <p>Penjelasan:</p> <ul> <li><code>npm start</code> merupakan perintah untuk menjalankan script <code>start</code> yang sudah didefinisikan di <code>package.json</code> (biasanya memanggil <code>expo start</code>).</li> <li><code>npx expo start</code> merupakan perintah untuk menjalankan perintah <code>expo start</code> langsung melalui npx, tanpa harus menginstalnya secara global.</li> <li><code>--tunnel</code> merupakan opsi untuk membuat koneksi melalui ngrok tunnel, sehingga aplikasi dapat diakses dari jaringan internet luar (bukan hanya jaringan lokal).</li> </ul> <p>Saat perintah ini dijalankan, Expo CLI akan:</p> <ol> <li>Membuka Metro Bundler di terminal atau browser.</li> <li>Menampilkan QR Code untuk memudahkan membuka aplikasi di perangkat fisik melalui Expo Go.</li> <li>Memberikan opsi menjalankan aplikasi di Android Emulator, iOS Simulator, atau browser (web).</li> </ol>"},{"location":"004-frontend/#42-struktur-project","title":"4.2. Struktur Project","text":"<pre><code>digit-recognition/\n\u251c\u2500\u2500 backend/                  # backend service (Flask API dan model machine learning)\n\u251c\u2500\u2500 frontend/                 # frontend application (React Native + Expo)\n\u2502   \u251c\u2500\u2500 app/                  # folder source code utama aplikasi Expo\n\u2502   \u2502   \u251c\u2500\u2500 _layout.jsx       # template yang digunakan\n\u2502   \u2502   \u2514\u2500\u2500 index.jsx         # halaman default saat pertama kali\n\u2502   \u251c\u2500\u2500 assets/               # folder untuk menyimpan aset (gambar, ikon, font, dll)\n\u2502   \u251c\u2500\u2500 node_modules/         # folder berisi dependensi project frontend\n\u2502   \u251c\u2500\u2500 app.json              # file konfigurasi utama Expo\n\u2502   \u2514\u2500\u2500 package.json          # file konfigurasi npm berisi daftar dependensi dan script\n</code></pre>"},{"location":"004-frontend/#43-frontend","title":"4.3. Frontend","text":""},{"location":"004-frontend/#431-_layoutjsx","title":"4.3.1. <code>_layout.jsx</code>","text":"<p>File <code>_layout.jsx</code> pada Expo Router berfungsi sebagai layout utama atau pembungkus halaman di dalam folder yang sama. File ini akan secara otomatis digunakan oleh semua halaman (<code>.jsx</code> atau <code>.js</code>) yang berada dalam direktori tersebut. Dengan adanya <code>_layout.jsx</code>, kita dapat mengatur navigasi, tema, atau konfigurasi global untuk seluruh halaman di dalamnya.</p> <pre><code>import { Stack } from 'expo-router'\n\nexport default function RootLayout() {\n  return &lt;Stack /&gt;\n}\n</code></pre> <p>Lakukan sedikit modifikasi dengan tujuan untuk menambahkan konfigurasi khusus pada setiap halaman.</p> <pre><code>import { Stack } from 'expo-router'\n\nexport default function RootLayout() {\n  return (\n    &lt;Stack&gt;\n      &lt;Stack.Screen name=\"index\" options={{ headerShown: false }} /&gt;\n    &lt;/Stack&gt;\n  )\n}\n</code></pre> <p>Kode <code>&lt;Stack.Screen name=\"index\" options={{ headerShown: false }} /&gt;</code> bertujuan untuk menambahkan konfigurasi pada halaman index misalnya <code>headerShown:false</code>, yaitu menghilangkan header default.</p>"},{"location":"004-frontend/#432-indexjsx","title":"4.3.2. <code>index.jsx</code>","text":"<p>File <code>index.jsx</code> bertindak sebagai halaman utama (home screen) yang pertama kali ditampilkan saat aplikasi dijalankan. Pada tahap ini, komponen masih berisi tampilan dasar dengan teks bawaan dari template Expo, yang ditempatkan di tengah layar menggunakan properti flexbox pada React Native.</p> <pre><code>import { Text, View } from 'react-native'\n\nexport default function Index() {\n  return (\n    &lt;View\n      style={{\n        flex: 1,\n        justifyContent: 'center',\n        alignItems: 'center',\n      }}\n    &gt;\n      &lt;Text&gt;Edit app/index.tsx to edit this screen.&lt;/Text&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre>"},{"location":"004-frontend/#433-componentsheaderjsx","title":"4.3.3. <code>components/Header.jsx</code>","text":"<p>Pada directory <code>app</code> anda bisa membuat directory baru dengan nama <code>components</code> yang merupakan directory yang digunakan untuk menyimpan semua komponen sehingga dapat digunakan kemabali jika diperlukan. file <code>Header.jsx</code> (Penamaan kompoenen diawali dengan huruf kapital) merupakan file yang berisikan komponen Header</p> <pre><code>import { Text, View } from 'react-native'\n\nexport default function Header(props) {\n  return (\n    &lt;View\n      style={{\n        backgroundColor: '#000',\n        paddingVertical: 10,\n        paddingHorizontal: 15,\n      }}\n    &gt;\n      &lt;Text\n        style={{\n          color: '#fff',\n          fontWeight: 900,\n          fontSize: 16,\n        }}\n      &gt;\n        {props.title || ''}\n      &lt;/Text&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre>"},{"location":"004-frontend/#434-componentsherojsx","title":"4.3.4. <code>components/Hero.jsx</code>","text":"<p>Pada tahap ini, kita membuat komponen <code>Hero.jsx</code> yang berfungsi sebagai bagian tampilan pembuka pada aplikasi. Komponen ini menampilkan judul (heading) dan deskripsi singkat mengenai fungsi aplikasi, yaitu pendeteksian angka dari tulisan tangan menggunakan teknologi AI. Seluruh elemen menggunakan <code>View</code> sebagai pembungkus, dengan dua elemen <code>Text</code> untuk judul dan deskripsi, serta pengaturan gaya (styling) langsung di dalam komponen agar tampilan rapi, terpusat, dan mudah dibaca.</p> <pre><code>import { Text, View } from 'react-native'\n\nexport default function Hero() {\n  return (\n    &lt;View\n      style={{\n        alignItems: 'center',\n        gap: 5,\n        paddingVertical: 20,\n        paddingHorizontal: 20,\n      }}\n    &gt;\n      &lt;Text\n        style={{\n          fontSize: 28,\n          textAlign: 'center',\n        }}\n      &gt;\n        Handwriting Digit Recognition\n      &lt;/Text&gt;\n      &lt;Text\n        style={{\n          fontSize: 14,\n          textAlign: 'center',\n          fontWeight: 300,\n        }}\n      &gt;\n        Use AI technology to recognize {'\\n'}\n        numbers from your handwriting {'\\n'}\n        quickly, accurately, and conveniently.\n      &lt;/Text&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre>"},{"location":"004-frontend/#435-componentsclassificationjsx","title":"4.3.5. <code>components/Classification.jsx</code>","text":"<p>Pada bagian ini, kita membuat komponen <code>Classification.jsx</code> yang bertanggung jawab sebagai area unggah (upload) gambar tulisan tangan untuk proses deteksi angka. Komponen ini menggunakan <code>useState</code> untuk menyimpan status loading dan hasil prediksi (predict) yang berisi informasi gambar serta hasil klasifikasi. Tombol unggah dibuat menggunakan <code>TouchableOpacity</code> dengan gaya border dashed untuk menandakan area drop/upload. Saat tombol ditekan, fungsi <code>pickImage()</code> akan dipanggil.</p> <pre><code>import axios from 'axios'\nimport * as ImagePicker from 'expo-image-picker'\nimport { useState } from 'react'\nimport {\n  ActivityIndicator,\n  Dimensions,\n  Image,\n  Text,\n  TouchableOpacity,\n  View,\n} from 'react-native'\nimport { PieChart } from 'react-native-chart-kit'\n\nexport default function Classification() {\n  const [loading, setLoading] = useState(false)\n  const [predict, setPredict] = useState({\n    image: null,\n    result: [],\n  })\n\n  function pickImage() {\n    console.log('pilih image')\n  }\n\n  return (\n    &lt;View\n      style={{\n        paddingHorizontal: 50,\n      }}\n    &gt;\n      &lt;Text\n        style={{\n          fontSize: 12,\n          fontWeight: 500,\n          color: '#aaa',\n          marginTop: 10,\n          textAlign: 'center',\n        }}\n      &gt;\n        Upload image here:\n      &lt;/Text&gt;\n      &lt;TouchableOpacity\n        style={{\n          display: 'flex',\n          borderColor: '#000',\n          borderStyle: 'dashed',\n          borderRadius: 4,\n          borderWidth: 2,\n          marginBottom: 10,\n        }}\n        onPress={pickImage}\n      &gt;\n        &lt;View\n          style={{\n            paddingVertical: 30,\n          }}\n        &gt;\n          &lt;Text style={{ textAlign: 'center' }}&gt;Click to upload&lt;/Text&gt;\n        &lt;/View&gt;\n      &lt;/TouchableOpacity&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre>"},{"location":"004-frontend/#436-classificationpickimage","title":"4.3.6 <code>Classification.pickImage</code>","text":"<pre><code>async function pickImage() {\n  try {\n    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync()\n    if (status !== 'granted') {\n      alert('Permission to access gallery is required!')\n      return\n    }\n    const imagePick = await ImagePicker.launchImageLibraryAsync({\n      mediaTypes: 'images',\n      allowsEditing: true,\n      quality: 1,\n    })\n\n    if (\n      !imagePick ||\n      imagePick.canceled ||\n      !Array.isArray(imagePick.assets) ||\n      imagePick.assets.length === 0\n    ) {\n      alert('No image selected')\n      return\n    }\n\n    setLoading(true)\n    const asset = imagePick.assets[0]\n\n    const formData = new FormData()\n    formData.append('file', {\n      uri: asset.uri,\n      name: asset.fileName || 'image.jpg',\n      type: asset.mimeType,\n    })\n\n    let response\n    response = await axios.post(\n      'http//localhost:5000', // URL Backend Flask\n      formData,\n      {\n        headers: { 'Content-Type': 'multipart/form-data' },\n        timeout: 60000,\n      }\n    )\n\n    const { image_url, classification_result } = response.data || {}\n    if (!Array.isArray(classification_result)) {\n      throw new Error('Invalid response format')\n    }\n\n    setPredict({\n      image: asset.uri,\n      result: classification_result,\n    })\n  } catch (error) {\n    const errorMessage = error.response\n      ? `Server error: ${error.response.status}`\n      : error.message || 'Failed to process image'\n    alert(errorMessage)\n    setPredict({\n      image: null,\n      result: [],\n    })\n  } finally {\n    setLoading(false)\n  }\n}\n</code></pre> <p>Fungsi <code>pickImage</code> pada komponen ini berperan untuk menangani seluruh proses pemilihan gambar dari galeri hingga mengirimkannya ke server backend untuk dilakukan klasifikasi angka tulisan tangan.</p> <p>Langkah kerjanya sebagai berikut:</p> <ol> <li>Meminta izin akses galeri menggunakan <code>ImagePicker.requestMediaLibraryPermissionsAsync()</code>. Jika izin tidak diberikan, proses dihentikan dengan menampilkan pesan peringatan.</li> <li>Membuka galeri menggunakan <code>ImagePicker.launchImageLibraryAsync()</code> dengan pengaturan hanya mengizinkan file gambar, mendukung pengeditan, dan kualitas maksimal.</li> <li>Validasi hasil pemilihan gambar memastikan bahwa pengguna benar-benar memilih file yang valid. Jika tidak, akan muncul peringatan \"No image selected\".</li> <li>Menyiapkan data untuk dikirim dengan membungkus gambar ke dalam objek <code>FormData</code>. Informasi yang dikirim mencakup <code>uri</code>, <code>name</code>, dan <code>type</code> file.</li> <li>Mengirim permintaan ke server Flask menggunakan <code>axios.post()</code> dengan <code>Content-Type</code> <code>multipart/form-data</code>. Server akan mengembalikan <code>image_url</code> dan <code>classification_result</code>.</li> <li>Menyimpan hasil prediksi ke dalam state <code>predict</code> jika data valid, termasuk URL gambar yang dipilih dan hasil klasifikasinya.</li> <li>Menangani kesalahan baik dari sisi jaringan, server, maupun format respons yang tidak sesuai, lalu mengosongkan data prediksi jika terjadi error.</li> <li>Mengatur status loading agar UI dapat menampilkan indikator proses selama unggah dan prediksi berlangsung.</li> </ol> <p>Catatan Lakukan import library yang diperlukan:</p> <ol> <li><code>import * as ImagePicker from 'expo-image-picker'</code></li> <li><code>import axios from 'axios'</code></li> </ol>"},{"location":"004-frontend/#437-classificationresult","title":"4.3.7. <code>Classification.Result</code>","text":"<pre><code>function Result(props) {\n  const { image, result } = props.prediction\n  const screenWidth = Dimensions.get('window').width\n\n  if (!image || !Array.isArray(result) || !(result.length &gt; 0)) return null\n\n  function getRandomColor() {\n    const letters = '0123456789ABCDEF'\n    let color = '#'\n    for (let i = 0; i &lt; 6; i++) {\n      color += letters[Math.floor(Math.random() * 16)]\n    }\n    return color\n  }\n\n  const chartSeries = result?.map((e, i) =&gt; ({\n    name: `Class ${e.class}`,\n    population: e.prob,\n    color: getRandomColor(),\n  }))\n\n  return (\n    &lt;View&gt;\n      &lt;Image\n        source={{ uri: image }}\n        style={{\n          height: undefined,\n          width: '100%',\n          aspectRatio: 1,\n          resizeMode: 'contain',\n        }}\n      /&gt;\n      &lt;View style={{ marginVertical: 20 }}&gt;\n        &lt;Text style={{ textAlign: 'center' }}&gt;Class Probability (%)&lt;/Text&gt;\n        &lt;PieChart\n          data={chartSeries}\n          width={screenWidth - 50}\n          height={220}\n          chartConfig={{\n            color: (opacity = 1) =&gt; `rgba(0, 0, 0, ${opacity})`,\n          }}\n          accessor=\"population\"\n          backgroundColor=\"transparent\"\n          paddingLeft=\"15\"\n          absolute\n          hasLegend\n        /&gt;\n      &lt;/View&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre> <p>Fungsi <code>Result</code> digunakan untuk menampilkan hasil prediksi klasifikasi angka tulisan tangan dalam bentuk gambar asli yang diunggah pengguna, sekaligus diagram pie yang memperlihatkan persentase probabilitas untuk setiap kelas.</p> <p>Alur kerjanya sebagai berikut:</p> <ol> <li> <p>Mengambil dan memvalidasi data prediksi</p> </li> <li> <p>Data <code>image</code> dan <code>result</code> diambil dari <code>props.prediction</code>.</p> </li> <li> <p>Jika gambar kosong (<code>!image</code>), <code>result</code> bukan array, atau array <code>result</code> kosong, maka fungsi langsung mengembalikan <code>null</code> dan tidak menampilkan apapun.</p> </li> <li> <p>Membuat fungsi warna acak</p> </li> <li> <p>Fungsi <code>getRandomColor()</code> menghasilkan warna acak dalam format heksadesimal (<code>#RRGGBB</code>) untuk membedakan tiap kelas pada pie chart.</p> </li> <li> <p>Memformat data untuk diagram pie</p> </li> <li> <p>Array <code>result</code> diubah menjadi <code>chartSeries</code>, yang berisi:</p> </li> <li> <p><code>name</code> \u2192 label kelas, misalnya Class 0, Class 1, dll.</p> </li> <li><code>population</code> \u2192 nilai probabilitas prediksi kelas tersebut.</li> <li> <p><code>color</code> \u2192 warna acak yang dibuat dari <code>getRandomColor()</code>.</p> </li> <li> <p>Menampilkan gambar hasil unggahan</p> </li> <li> <p>Menggunakan <code>Image</code> dengan <code>aspectRatio: 1</code> agar proporsi tidak berubah.</p> </li> <li> <p><code>resizeMode: 'contain'</code> menjaga gambar tetap utuh tanpa terpotong.</p> </li> <li> <p>Menampilkan diagram pie probabilitas kelas</p> </li> <li> <p>Menggunakan komponen <code>PieChart</code> untuk memvisualisasikan persentase probabilitas setiap kelas.</p> </li> <li>Lebar pie chart disesuaikan dengan ukuran layar (<code>screenWidth - 50</code>).</li> <li><code>absolute</code> dan <code>hasLegend</code> digunakan agar label dan nilai persentase ditampilkan jelas di luar chart.</li> </ol> <p>Hasilnya, pengguna dapat melihat gambar yang diprediksi beserta distribusi persentase probabilitas setiap kelas secara visual dan informatif.</p>"},{"location":"004-frontend/#44-kode-final","title":"4.4. Kode Final","text":""},{"location":"004-frontend/#441-_layoutjsx","title":"4.4.1. <code>_layout.jsx</code>","text":"<pre><code>import { Stack } from 'expo-router'\n\nexport default function RootLayout() {\n  return (\n    &lt;Stack&gt;\n      &lt;Stack.Screen name=\"index\" options={{ headerShown: false }} /&gt;\n    &lt;/Stack&gt;\n  )\n}\n</code></pre>"},{"location":"004-frontend/#442-indexjsx","title":"4.4.2. <code>index.jsx</code>","text":"<pre><code>import { ScrollView, View } from 'react-native'\nimport Classification from './components/Classification'\nimport Header from './components/Header'\nimport Hero from './components/Hero'\n\nexport default function Index() {\n  return (\n    &lt;View\n      style={{\n        flex: 1,\n        marginTop: 40,\n      }}\n    &gt;\n      &lt;Header title={'Handwriting Recognition'} /&gt;\n      &lt;ScrollView&gt;\n        &lt;Hero /&gt;\n        &lt;Classification /&gt;\n      &lt;/ScrollView&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre>"},{"location":"004-frontend/#443-componentsheaderjsx","title":"4.4.3. <code>components/Header.jsx</code>","text":"<pre><code>import { Text, View } from 'react-native'\n\nexport default function Header(props) {\n  return (\n    &lt;View\n      style={{\n        backgroundColor: '#000',\n        paddingVertical: 10,\n        paddingHorizontal: 15,\n      }}\n    &gt;\n      &lt;Text\n        style={{\n          color: '#fff',\n          fontWeight: 900,\n          fontSize: 16,\n        }}\n      &gt;\n        {props.title || ''}\n      &lt;/Text&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre>"},{"location":"004-frontend/#444-componentsherojsx","title":"4.4.4. <code>components/Hero.jsx</code>","text":"<pre><code>import { Text, View } from 'react-native'\n\nexport default function Hero() {\n  return (\n    &lt;View\n      style={{\n        alignItems: 'center',\n        gap: 5,\n        paddingVertical: 20,\n        paddingHorizontal: 20,\n      }}\n    &gt;\n      &lt;Text\n        style={{\n          fontSize: 28,\n          textAlign: 'center',\n        }}\n      &gt;\n        Handwriting Digit Recognition\n      &lt;/Text&gt;\n      &lt;Text\n        style={{\n          fontSize: 14,\n          textAlign: 'center',\n          fontWeight: 300,\n        }}\n      &gt;\n        Use AI technology to recognize {'\\n'}\n        numbers from your handwriting {'\\n'}\n        quickly, accurately, and conveniently.\n      &lt;/Text&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre>"},{"location":"004-frontend/#445-componentsclassificationjsx","title":"4.4.5. <code>components/Classification.jsx</code>","text":"<pre><code>import axios from 'axios'\nimport * as ImagePicker from 'expo-image-picker'\nimport { useState } from 'react'\nimport {\n  ActivityIndicator,\n  Dimensions,\n  Image,\n  Text,\n  TouchableOpacity,\n  View,\n} from 'react-native'\nimport { PieChart } from 'react-native-chart-kit'\n\nexport default function Classification() {\n  const [loading, setLoading] = useState(false)\n  const [predict, setPredict] = useState({\n    image: null,\n    result: [],\n  })\n\n  async function pickImage() {\n    try {\n      const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync()\n      if (status !== 'granted') {\n        alert('Permission to access gallery is required!')\n        return\n      }\n      const imagePick = await ImagePicker.launchImageLibraryAsync({\n        mediaTypes: 'images',\n        allowsEditing: true,\n        quality: 1,\n      })\n\n      if (\n        !imagePick ||\n        imagePick.canceled ||\n        !Array.isArray(imagePick.assets) ||\n        imagePick.assets.length === 0\n      ) {\n        alert('No image selected')\n        return\n      }\n\n      setLoading(true)\n      const asset = imagePick.assets[0]\n\n      const formData = new FormData()\n      formData.append('file', {\n        uri: asset.uri,\n        name: asset.fileName || 'image.jpg',\n        type: asset.mimeType,\n      })\n\n      let response\n      response = await axios.post(\n        'http//localhost:5000', // URL Backend Flask\n        formData,\n        {\n          headers: { 'Content-Type': 'multipart/form-data' },\n          timeout: 60000,\n        }\n      )\n      const { classification_result } = response.data || {}\n      if (!Array.isArray(classification_result)) {\n        throw new Error('Invalid response format')\n      }\n\n      setPredict({\n        image: asset.uri,\n        result: classification_result,\n      })\n      console.log(predict)\n    } catch (error) {\n      const errorMessage = error.response\n        ? `Server error: ${error.response.status}`\n        : error.message || 'Failed to process image'\n      alert(errorMessage)\n      setPredict({\n        image: null,\n        result: [],\n      })\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  return (\n    &lt;View\n      style={{\n        paddingHorizontal: 50,\n      }}\n    &gt;\n      &lt;Text\n        style={{\n          fontSize: 12,\n          fontWeight: 500,\n          color: '#aaa',\n          marginTop: 10,\n          textAlign: 'center',\n        }}\n      &gt;\n        Upload image here:\n      &lt;/Text&gt;\n      &lt;TouchableOpacity\n        style={{\n          display: 'flex',\n          borderColor: '#000',\n          borderStyle: 'dashed',\n          borderRadius: 4,\n          borderWidth: 2,\n          marginBottom: 10,\n        }}\n        onPress={pickImage}\n      &gt;\n        &lt;View\n          style={{\n            paddingVertical: 30,\n          }}\n        &gt;\n          &lt;Text style={{ textAlign: 'center' }}&gt;Click to upload&lt;/Text&gt;\n        &lt;/View&gt;\n      &lt;/TouchableOpacity&gt;\n      {loading &amp;&amp; &lt;ActivityIndicator size={'large'} color={'#000'} /&gt;}\n      {predict &amp;&amp; predict.image &amp;&amp; predict.result &amp;&amp; (\n        &lt;Result prediction={predict} /&gt;\n      )}\n    &lt;/View&gt;\n  )\n}\n\nfunction Result(props) {\n  const { image, result } = props.prediction\n  const screenWidth = Dimensions.get('window').width\n\n  if (!image || !Array.isArray(result) || !(result.length &gt; 0)) return null\n\n  function getRandomColor() {\n    const letters = '0123456789ABCDEF'\n    let color = '#'\n    for (let i = 0; i &lt; 6; i++) {\n      color += letters[Math.floor(Math.random() * 16)]\n    }\n    return color\n  }\n\n  const chartSeries = result?.map((e, i) =&gt; ({\n    name: `Class ${e.class}`,\n    population: e.prob,\n    color: getRandomColor(),\n  }))\n\n  return (\n    &lt;View&gt;\n      &lt;Image\n        source={{ uri: image }}\n        style={{\n          height: undefined,\n          width: '100%',\n          aspectRatio: 1,\n          resizeMode: 'contain',\n        }}\n      /&gt;\n      &lt;View style={{ marginVertical: 20 }}&gt;\n        &lt;Text style={{ textAlign: 'center' }}&gt;Class Probability (%)&lt;/Text&gt;\n        &lt;PieChart\n          data={chartSeries}\n          width={screenWidth - 50}\n          height={220}\n          chartConfig={{\n            color: (opacity = 1) =&gt; `rgba(0, 0, 0, ${opacity})`,\n          }}\n          accessor=\"population\"\n          backgroundColor=\"transparent\"\n          paddingLeft=\"15\"\n          absolute\n          hasLegend\n        /&gt;\n      &lt;/View&gt;\n    &lt;/View&gt;\n  )\n}\n</code></pre>"}]}